<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WaveSurfer Crossfade Player</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 2em;
      background: #fff;
      color: #000;
      transition: background 0.3s, color 0.3s;
    }
    body.dark {
      background: #121212;
      color: #eee;
    }
    input, select, button {
      margin: 0.4em;
      padding: 0.5em 1em;
      font-size: 1em;
    }
    #waveform {
      margin: 1.5em auto;
      width: 90%;
      height: 80px;
      cursor: pointer;
    }

    /* Moved left so the full button is visible */
    .toggle {
      position: fixed;
      top: 10px;
      right: 80px;
      background: #ccc;
      padding: 0.3em 0.6em;
      border-radius: 5px;
      cursor: pointer;
      user-select: none;
      z-index: 999;
    }

    /* Sound FX Button */
    .fxBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #ccc;
      padding: 0.3em 0.6em;
      border-radius: 5px;
      cursor: pointer;
      user-select: none;
      z-index: 999;
    }

    /* Slide-out FX panel */
    #fxPanel {
      position: fixed;
      top: 50px;
      right: -320px;
      width: 300px;
      background: #ddd;
      padding: 1em;
      border-radius: 10px 0 0 10px;
      box-shadow: -3px 0 8px rgba(0,0,0,0.25);
      transition: right 0.3s;
      z-index: 998;
    }
    #fxPanel.show {
      right: 0;
    }

    .controls {
      margin-top: 1em;
    }
    #volumeControl {
      display: inline-flex;
      align-items: center;
      margin-left: 1em;
    }
    #muteBtn {
      margin-left: 0.4em;
      font-size: 1.5em;
      cursor: pointer;
    }
    .note {
      margin-top: 2em;
      color: gray;
      font-style: italic;
    }

    /* Each sound effect button */
    .fxItem {
      width: 100%;
      margin: 0.3em 0;
      padding: 0.4em;
      background: #bbb;
      border-radius: 6px;
      cursor: pointer;
    }
  </style>
  <script src="https://unpkg.com/wavesurfer.js"></script>
</head>
<body>
  <div class="toggle" id="darkToggle">Toggle Dark Mode</div>

  <!-- SOUND EFFECTS BUTTON -->
  <div class="fxBtn" id="fxToggle">Sound Effects</div>

  <!-- SOUND EFFECTS PANEL -->
  <div id="fxPanel">
    <h3>Sound Effects</h3>
    <input type="file" id="fxInput" accept="audio/*" multiple />

    <!-- SFX volume slider -->
    <label>Volume:
      <input type="range" id="fxVolume" min="0" max="1" step="0.01" value="1">
    </label>

    <div id="fxList"></div>
  </div>

  <h2>Waveform Audio Player with Crossfade</h2>

  <input type="file" id="fileInput" accept="audio/*" multiple />
  <select id="trackList"></select>

  <div class="controls">
    <button id="playBtn">Play</button>
    <button id="pauseBtn">Pause</button>
    <div id="volumeControl">
      <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1" />
      <span id="muteBtn" title="Mute/Unmute">ðŸ”Š</span>
    </div>
    <label style="margin-left: 1em;">
      Crossfade (sec):
      <input type="number" id="fadeDuration" min="0" step="0.1" value="2" style="width: 4em;" />
    </label>
  </div>

  <div id="waveform"></div>

  <button id="saveBtn">ðŸ’¾ Save Playlist</button>
  <button id="loadBtn">ðŸ“‚ Load Playlist</button>

  <div class="note">
    How it works: Press play/pause for fade. Seek with waveform. Auto fade at end. Controls disabled during final fade.
  </div>

  <script>
    const waveform = WaveSurfer.create({
      container: '#waveform',
      waveColor: '#999',
      progressColor: '#2e86de',
      height: 80,
      cursorColor: '#333',
      interact: true,
    });

    const darkToggle = document.getElementById('darkToggle');
    const fileInput = document.getElementById('fileInput');
    const trackList = document.getElementById('trackList');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const volumeSlider = document.getElementById('volumeSlider');
    const muteBtn = document.getElementById('muteBtn');
    const fadeInput = document.getElementById('fadeDuration');
    const saveBtn = document.getElementById('saveBtn');
    const loadBtn = document.getElementById('loadBtn');

    /* SOUND EFFECTS ELEMENTS */
    const fxToggle = document.getElementById('fxToggle');
    const fxPanel = document.getElementById('fxPanel');
    const fxInput = document.getElementById('fxInput');
    const fxList = document.getElementById('fxList');
    const fxVolumeSlider = document.getElementById('fxVolume');

    let fxVolume = 1;
    let files = [], isMuted = false, savedVolume = 1, isEnding = false;
    let fxBuffers = [];

    /* TOGGLE FX PANEL */
    fxToggle.onclick = () => {
      fxPanel.classList.toggle('show');
    };

    /* LOAD SOUND EFFECTS */
    fxInput.onchange = e => {
      const items = [...e.target.files];
      items.forEach(file => {
        const url = URL.createObjectURL(file);
        const audio = new Audio(url);
        audio.volume = fxVolume;

        fxBuffers.push(audio);

        const btn = document.createElement('div');
        btn.className = 'fxItem';
        btn.textContent = file.name;
        btn.onclick = () => {
          const sound = new Audio(url);
          sound.volume = fxVolume;
          sound.play();
        };

        fxList.appendChild(btn);
      });
    };

    /* FX VOLUME */
    fxVolumeSlider.oninput = () => {
      fxVolume = parseFloat(fxVolumeSlider.value);
    };

    /* Dark mode */
    if (localStorage.getItem('darkMode') === 'true') document.body.classList.add('dark');
    darkToggle.onclick = () => {
      document.body.classList.toggle('dark');
      localStorage.setItem('darkMode', document.body.classList.contains('dark'));
    };

    /* Load volume/mute */
    if (localStorage.getItem('volume')) {
      savedVolume = parseFloat(localStorage.getItem('volume'));
      volumeSlider.value = savedVolume;
    }
    if (localStorage.getItem('muted')) {
      isMuted = localStorage.getItem('muted') === 'true';
    }
    updateVolume();

    /* Playlist save/load */
    saveBtn.onclick = () => {
      const names = files.map(f => f.name);
      localStorage.setItem('playlistNames', JSON.stringify(names));
      alert('Playlist saved. Re-upload files to play.');
    };

    loadBtn.onclick = () => {
      const names = JSON.parse(localStorage.getItem('playlistNames') || '[]');
      if (!names.length) return alert('No playlist found.');
      files = [];
      trackList.innerHTML = '';
      names.forEach(name => {
        const opt = document.createElement('option');
        opt.textContent = name + ' (re-upload needed)';
        opt.disabled = true;
        trackList.appendChild(opt);
      });
    };

    /* Volume control */
    volumeSlider.oninput = () => {
      savedVolume = parseFloat(volumeSlider.value);
      isMuted = savedVolume === 0;
      updateVolume();
    };

    muteBtn.onclick = () => {
      isMuted = !isMuted;
      updateVolume();
    };

    function updateVolume() {
      waveform.setVolume(isMuted ? 0 : savedVolume);
      muteBtn.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
      localStorage.setItem('volume', savedVolume);
      localStorage.setItem('muted', isMuted);
    }

    /* Load main audio */
    fileInput.onchange = e => {
      files = [...e.target.files];
      trackList.innerHTML = '';
      files.forEach((f, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = f.name;
        trackList.appendChild(opt);
      });
      if (files.length) loadTrack(0);
    };

    trackList.onchange = () => {
      const i = parseInt(trackList.value);
      if (!isNaN(i)) loadTrack(i);
    };

    function loadTrack(index) {
      const file = files[index];
      if (!file) return;
      const url = URL.createObjectURL(file);
      waveform.load(url);
      trackList.value = index;
    }

    /* Crossfade */
    function fade(from, to, duration) {
      return new Promise(resolve => {
        const steps = 30;
        let current = 0;
        const stepTime = (duration * 1000) / steps;
        const step = () => {
          current++;
          let v = from + ((to - from) * current / steps);
          waveform.setVolume(isMuted ? 0 : v);
          if (current < steps) setTimeout(step, stepTime);
          else resolve();
        };
        step();
      });
    }

    /* Faded Play */
    playBtn.onclick = async () => {
      if (isEnding) return;
      const dur = parseFloat(fadeInput.value) || 0;
      waveform.setVolume(0);
      waveform.play();
      await fade(0, isMuted ? 0 : savedVolume, dur);
    };

    /* Faded Pause */
    pauseBtn.onclick = async () => {
      if (isEnding) return;
      const dur = parseFloat(fadeInput.value) || 0;
      await fade(isMuted ? 0 : savedVolume, 0, dur);
      waveform.pause();
    };

    /* Auto fade */
    waveform.on('audioprocess', () => {
      const timeLeft = waveform.getDuration() - waveform.getCurrentTime();
      if (!isEnding && timeLeft <= (parseFloat(fadeInput.value) || 2)) {
        isEnding = true;
        playBtn.disabled = true;
        pauseBtn.disabled = true;
        fade(savedVolume, 0, timeLeft).then(() => {
          waveform.pause();
          playBtn.disabled = false;
          pauseBtn.disabled = false;
          isEnding = false;
        });
      }
    });
  </script>
</body>
</html>
